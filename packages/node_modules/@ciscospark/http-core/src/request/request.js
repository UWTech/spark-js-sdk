/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {detect} from '../lib/detect';
import ProgressEvent from '../progress-event';
import request from 'request';

/**
 * @param {Object} options
 * @private
 * @returns {Promise}
 */
function prepareOptions(options) {
  if (options.responseType === `buffer` || options.responseType === `blob`) {
    options.encoding = null;
  }

  if (options.withCredentials) {
    options.jar = true;
  }

  if (Buffer.isBuffer(options.body)) {
    return detect(options.body)
      .then((type) => {
        options.headers[`content-type`] = type;
        return options;
      });
  }

  return Promise.resolve(options);
}

/**
 * @param {Object} options
 * @private
 * @returns {Promise}
 */
function doRequest(options) {
  return new Promise((resolve) => {
    const logger = options.logger;

    const r = request(options, (error, response) => {
      if (error) {
        logger.warn(error);
      }

      if (response) {
        response.options = options;

        // I'm not sure why this line is necessary. request seems to be creating
        // buffers that aren't Buffers.
        if (options.responseType === `buffer` && response.body.type === `Buffer` && !Buffer.isBuffer(response.body)) {
          response.body = new Buffer(response.body);
        }

        if (Buffer.isBuffer(response.body) && !response.body.type) {
          resolve(detect(response.body)
            .then((type) => {
              response.body.type = type;
              return response;
            }));

          return;
        }

        resolve(response);
      }
      else {
        // Make a network error behave like a browser network error.
        // TODO:: if the status code is a 429, store the retry-after,
        // or create new retry after as appropriate
        resolve({
          statusCode: 0,
          options,
          headers: options.headers,
          method: options.method,
          url: options.url,
          body: error
        });
      }
    });

    r.on(`response`, (response) => {
      const total = parseInt(response.headers[`content-length`], 10);
      let loaded = 0;
      response.on(`data`, (data) => {
        loaded += data.length;
        options.download.emit(`progress`, new ProgressEvent(loaded, total));
      });
    });
  });
}

/**
 * @name request
 * @param {Object} options
 * @returns {Promise}
 */
export default function _request(options) {
  // if so reject request if retry-after indicates it is too early to try again
  // if appropriate amount of time has passed, refresh the table to indicate no 429 currently exists
  if (isRateLimited(options.uri)) {
    return new Promise((resolve) => {
      resolve({
        statusCode: 429,
        options,
        headers: options.headers,
        method: options.method,
        url: options.url,
        body: `TooManyRequests`
      });
    });
  }
  return prepareOptions(options)
    .then(doRequest);
}

// contains API to Expiry of rate limiting mapping
const rateLimitExpiryTime = {};

/**
 * Sets the system time at which the rate limiting
 * will expire in the rateLimitExpiry map.
 * Assumes retryAfter is in seconds (S)
 * @param {string} uri API issuing the rate limiting
 * @param {number} retryAfter seconds until rate limiting expires
 * @returns {number} time in seconds the rate limiting will expire
 */
function setRateLimitExpiry(uri, retryAfter) {
  const apiName = _getApiName(uri);
  const currTimeSec = new Date().getTime() / 1000;
  rateLimitExpiryTime[apiName] = currTimeSec + retryAfter;
  return rateLimitExpiryTime[apiName];
}
export {setRateLimitExpiry};
/**
 * returns true if the API is currently rate limited
 * @param {string} uri
 * @returns {Boolean} indicates whether or not the API is rate crrently rate limited
 */
function _getRateLimitStatus(uri) {
  const apiName = _getApiName(uri);
  const currTimeSec = new Date().getTime() / 1000;
  return rateLimitExpiryTime[apiName] === null ? false : currTimeSec > rateLimitExpiryTime[apiName];
}

// extracts the common identity API being called
const idBrokerRegex = /.*idbroker.webex.com\/([^\/]+)/;

/**
 * splits the URI and returns the API name of idBroker
 * @param {string} uri
 * @returns {string}
 */
function _getApiName(uri) {
  const results = uri.match(idBrokerRegex);
  return results === null ? null : results[1];
}

/**
 * check URI against list of currently rate limited
 * URIs, and determines if retry-after
 * @param {String} uri pattern to check
 * @returns {bool}
 */
function isRateLimited(uri) {
  // determine if the URI is associated with a common identity API
  if (uri.includes(`idbroker`)) {
    return _getRateLimitStatus(uri);
  }
  return false;
}
