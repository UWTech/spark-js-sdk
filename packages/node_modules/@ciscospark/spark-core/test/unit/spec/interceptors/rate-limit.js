/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/* eslint-disable camelcase */
import {assert} from '@ciscospark/test-helper-chai';
import MockSpark from '@ciscospark/test-helper-mock-spark';
import {
  RateLimitInterceptor,
  config,
  Credentials,
  SparkHttpError,
  Token
} from '@ciscospark/spark-core';
import {cloneDeep} from 'lodash';
describe(`spark-core`, () => {
  describe(`Interceptors`, () => {
    describe(`RateLimitInterceptor`, () => {

      let interceptor, spark;
      beforeEach(() => {
        spark = new MockSpark({
          children: {
            credentials: Credentials
          },
          config: cloneDeep(config)
        });

        spark.credentials.supertoken = new Token({
          access_token: `ST1`,
          token_type: `Bearer`
        }, {parent: spark});

        interceptor = Reflect.apply(RateLimitInterceptor.create, spark, []);
      });

      describe(`#isRateLimited`, () => {
        it(`returns false when URI is not IDbroker URI`, () => {
          assert.equal(interceptor.isRateLimited(`https://fakeuir.com/testFake`), false);
        });
        it(`returns false if the URI is null`, () => {
          assert.equal(interceptor.isRateLimited(null), false);
        });
        it(`returns true when API is rate limited`, () => {
          interceptor.setRateLimitExpiry(`https://idbroker.webex.com/horse/v1/myID`, new Date().getTime() * 2);
          assert.equal(interceptor.isRateLimited(`https://idbroker.webex.com/horse/v1/myID`), true);
        });
        it(`returns false when previously rate limited API expiry time has been met`, () => {
          function sleep(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
          }

          async function sleepForExpiry() {
            await sleep(2000);
          }

          interceptor.setRateLimitExpiry(`https://idbroker.webex.com/horse/v1/myID`, 1);
          sleepForExpiry().then(() => {
            assert.equal(interceptor.isRateLimited(`https://idbroker.webex.com/horse/v1/myID`), false);
          });
        });
      });

      describe(`#getApiName`, () => {
        it(`returns null when there is no regex match`, () => {
          assert.equal(interceptor.getApiName(`https://fakeuir.com/testFake`), null);
        });
        it(`returns null when the argument is null`, () => {
          assert.equal(interceptor.getApiName(null), null);
        });
        it(`returns API name if there is a match`, () => {
          assert.equal(interceptor.getApiName(`https://idbroker.webex.com/horse/v1/myID`), `horse`);
        });
      });

      describe(`#getRateLimitStatus`, () => {
        it(`returns false if API name is not in rate limit expiry map`, () => {
          assert.equal(interceptor.getRateLimitStatus(`https://fakeuir.com/testFake`), false);
        });
        it(`returns false if API name is not rate limited`, () => {
          interceptor.setRateLimitExpiry(`https://idbroker.webex.com/horse/v1/myID`, 1);
          function sleep(time) {
            return new Promise((resolve) => setTimeout(resolve, time));
          }
          sleep(2000).then(() => {
            assert.equal(interceptor.getRateLimitStatus(`https://idbroker.webex.com/horse/v1/myID`), false);
          });
        });
        it(`returns true if the API name is rate limited`, () => {
          const future = (new Date().getTime() / 1000) * 2;
          interceptor.setRateLimitExpiry(`https://idbroker.webex.com/horse/v1/myID`, future);
          assert.equal(interceptor.getRateLimitStatus(`https://idbroker.webex.com/horse/v1/myID`), true);
        });
      });

      describe(`#setRateLimitExpiry`, () => {
        it(`returns false if URI results in API name that is null`, () => {
          assert.equal(interceptor.setRateLimitExpiry(`https://fakeuir.com/testFake`, 1), null);
        });
        it(`sets expiry if URI results in API name that can be mapped`, () => {
          interceptor.setRateLimitExpiry(`https://idbroker.webex.com/horse/v1/myID`, new Date().getTime() * 2);
          assert.equal(interceptor.getRateLimitStatus(`https://idbroker.webex.com/horse/v1/myID`), true);
        });
      });

      describe(`#getRetryAfterTime`, () => {
        it(`returns 60 seconds when retry-after <= 0`, () => {
          assert.equal(interceptor.getRetryAfterTime({
            headers: {'retry-after': -1}}), 60);
        });
        it(`returns 60 seconds when retry-after is null`, () => {
          assert.equal(interceptor.getRetryAfterTime({
            headers: {'retry-after-missing': 10}}), 60);
        });
        it(`returns 3600 seconds when retry-after is > 3600`, () => {
          assert.equal(interceptor.getRetryAfterTime({
            headers: {'retry-after': 7200}}), 3600);
        });
        it(`returns retry-after as is if 0 < retry-after < 3600`, () => {
          assert.equal(interceptor.getRetryAfterTime({
            headers: {'retry-after': 55}}), 55);
        });
      });

      describe(`#onRequest`, () => {
        it(`Rejects request if API is rate limited`, () => {
          const future = (new Date().getTime() / 1000) * 2;
          interceptor.setRateLimitExpiry(`https://idbroker.webex.com/horse/v1/myID`, future);
          return interceptor.onRequest({uri: `https://idbroker.webex.com/horse/v1/myID`}).catch((err) => {
            assert.notCalled(spark.request);
            assert.equal(err.message, `API rate limited https://idbroker.webex.com/horse/v1/myID`);
          });
        });
        it(`Does not reject request if API is not rate limited`, () => {
          const options = {uri: `https://idbroker.webex.com/horse/v1/myID`};
          return interceptor.onRequest(options).then((result) => {
            assert.equal(result, options);
          });
        });
      });

      describe(`#onResponseError`, () => {
        const err429 = new SparkHttpError.TooManyRequests({
          statusCode: 429,
          options: {
            headers: {
              trackingid: `test`,
              'retry-after': 60
            },
            uri: `https://idbroker.webex.com/horse/v1/myID`
          },
          body: {
            error: `Too Many Requests`
          }
        });
        const err429notIdBroker = new SparkHttpError.TooManyRequests({
          statusCode: 429,
          options: {
            headers: {
              trackingid: `test`,
              'retry-after': 60
            },
            uri: `https://google.com/horse/v1/myID`
          },
          body: {
            error: `Too Many Requests`
          }
        });
        const err404 = new SparkHttpError.BadRequest({
          statusCode: 404,
          options: {
            headers: {
              trackingid: `test`,
              'retry-after': 60
            },
            uri: `https://idbroker.webex.com/horse/v1/myID`
          },
          body: {
            error: `Resource Not Found`
          }
        });

        const optionsIdBroker = {
          headers: {
            trackingid: `test`,
            'retry-after': 60
          },
          uri: `https://idbroker.webex.com/horse/v1/myID`
        };

        const optionsNotIdBroker = {
          headers: {
            trackingid: `test`,
            'retry-after': 60
          },
          uri: `https://google.com/horse/v1/myID`
        };
        it(`Stores API name and retry-after when status code is 429 and URI is idbroker`, () => {
          interceptor.onResponseError(optionsIdBroker, err429).catch((resp) => {
            assert.equal(interceptor.isRateLimited(`https://idbroker.webex.com/horse/v1/myID`), true);
            assert.equal(resp, err429);
          });
        });
        it(`Does not store API name and retry-after when URI is idbroker and status code is not 429`, () => {
          interceptor.onResponseError(optionsIdBroker, err404).catch((resp) => {
            assert.equal(interceptor.isRateLimited(`https://idbroker.webex.com/horse/v1/myID`), false);
            assert.equal(resp, err404);
          });
        });
        it(`Does not store API name and retry-after when status is 429 and URI is not idbroker`, () => {
          interceptor.onResponseError(optionsNotIdBroker, err429notIdBroker).catch((resp) => {
            assert.equal(interceptor.isRateLimited(`https://google.com/horse/v1/myID`), false);
            assert.equal(resp, err429notIdBroker);
          });
        });
      });
    });
  });
});
