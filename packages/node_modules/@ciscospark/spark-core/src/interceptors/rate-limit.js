/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {Interceptor} from '@ciscospark/http-core';

// contains the system time in seconds at which the retry after associated with a 429 expires
// mapped by the API name, e.g.: idbroker.webex.com/doStuff would be mapped as 'doStuff'
const rateLimitExpiryTime = new WeakMap();

// extracts the common identity API being called
const idBrokerRegex = /.*idbroker.webex.com\/([^\/]+)/;

/**
 * @class
 */
export default class RateLimitInterceptor extends Interceptor {

  /**
   * @returns {RateLimitInterceptor}
   */
  static create() {
    return new RateLimitInterceptor({spark: this});
  }

  /**
  * constructor
  * @param {mixed} args
  * @returns {Exception}
  */
  constructor(...args) {
    super(...args);
    rateLimitExpiryTime.set(this, new Map());
  }
    /**
   * @see {@link Interceptor#onRequest}
   * @param {Object} options
   * @returns {Object}
   */
  onRequest(options) {
    if (this.isRateLimited(options.uri)) {
      return Promise.reject(
        new Error(`API rate limited ${options.uri}`)
      );
    }
    return Promise.resolve(options);
  }
  /**
   * @see {@link Interceptor#onResponseError}
   * @param {Object} options
   * @param {Error} reason
   * @returns {Object}
   */
  onResponseError(options, reason) {
    if (reason.statusCode === 429 && options.uri.includes(`idbroker`)) {
      // set the retry after in the map
      this.setRateLimitExpiry(options.uri, this.getRetryAfterTime(options));
    }
    return Promise.reject(reason);
  }

  /**
   * @param {object} options associated with the request
   * @returns {number} retry after time in seconds
   */
  getRetryAfterTime(options) {
    const retryAfter = options.headers[`retry-after`] || null;
    if (retryAfter === null || retryAfter <= 0) {
      return 60;
    }
    else if (retryAfter > 3600) {
      return 3600;
    }
    return retryAfter;
  }

  /**
   * Sets the system time at which the rate limiting
   * will expire in the rateLimitExpiryTime map.
   * Assumes retryAfter is in seconds (S)
   * @param {string} uri API issuing the rate limiting
   * @param {number} retryAfter seconds until rate limiting expires
   * @returns {bool} true is value was successfully set
   */
  setRateLimitExpiry(uri, retryAfter) {
    const apiName = this.getApiName(uri);
    const currTimeSec = new Date().getTime() / 1000;
    const expiry = currTimeSec + retryAfter;
    const dict = rateLimitExpiryTime.get(this);
    return apiName && dict && dict.set(apiName, expiry);
  }

  /**
   * returns true if the API is currently rate limited
   * @param {string} uri
   * @returns {Boolean} indicates whether or not the API is rate currently rate limited
   */
  getRateLimitStatus(uri) {
    const apiName = this.getApiName(uri);
    const currTimeSec = new Date().getTime() / 1000;
    const dict = rateLimitExpiryTime.get(this);
    return dict && dict.get(apiName) === null ? false : currTimeSec < dict.get(apiName);
  }

  /**
   * splits the URI and returns the API name of idBroker
   * @param {string} uri
   * @returns {string}
   */
  getApiName(uri) {
    const results = uri === null ? null : uri.match(idBrokerRegex);
    return results === null ? null : results[1];
  }

  /**
   * check URI against list of currently rate limited
   * URIs, and determines if retry-after
   * @param {String} uri pattern to check
   * @returns {bool}
   */
  isRateLimited(uri) {
    // determine if the URI is associated with a common identity API
    if (uri && uri.includes(`idbroker`)) {
      return this.getRateLimitStatus(uri);
    }
    return false;
  }
}
