/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@ciscospark/test-helper-chai';
import Metrics, {config} from '@ciscospark/internal-plugin-metrics';
import MockSpark from '@ciscospark/test-helper-mock-spark';
import sinon from '@ciscospark/test-helper-sinon';

describe(`plugin-metrics`, () => {
  describe(`Metrics`, () => {
    let spark;
    let metrics;
    const eventName = `test_event`;
    const mockPayload = {
      fields: {
        testField: 123
      },
      tags: {
        testTag: `tag value`
      },
      metricName: eventName,
      test: `this field should not be included in final payload`,
      type: `behavioral`
    };
    const transformedProps = {
      fields: {
        testField: 123
      },
      tags: {
        testTag: `tag value`
      },
      metricName: eventName,
      type: `behavioral`
    };
    const preLoginId = `1b90cf5e-27a6-41aa-a208-1f6eb6b9e6b6`;
    const preLoginProps = {
      metrics: [
        transformedProps
      ]
    };
    const mockCallDiagnosticEvent = {
      originTime: {
        triggered: `mock triggered timestamp`
      }
    };
    const testPayload = {
      tags: {success: true},
      fields: {perceivedDurationInMillis: 314}
    };
    beforeEach(() => {
      spark = new MockSpark({
        children: {
          metrics: Metrics
        }
      });

      spark.config.metrics = config.metrics;
      metrics = spark.internal.metrics;
      // clear map of values from previous tests
      metrics.metricMap = new Map();

      spark.request = function(options) {
        return Promise.resolve({
          statusCode: 204,
          body: undefined,
          options
        });
      };
      sinon.spy(spark, `request`);
      sinon.spy(metrics, `postPreLoginMetric`);
      sinon.spy(metrics, `aliasUser`);
      sinon.spy(metrics, `submitCallDiagnosticEvents`);
    });

    describe(`#submit()`, () => {
      it(`submits a metric`, () => {
        return metrics.submit(`testMetric`)
          .then(() => {
            assert.calledOnce(spark.request);
            const req = spark.request.args[0][0];
            const metric = req.body.metrics[0];

            assert.property(metric, `key`);
            assert.property(metric, `version`);
            assert.property(metric, `appType`);
            assert.property(metric, `env`);
            assert.property(metric, `time`);
            assert.property(metric, `version`);

            assert.equal(metric.key, `testMetric`);
            assert.equal(metric.version, spark.version);
            assert.equal(metric.env, `TEST`);
          });
      });
    });

    describe(`#submitClientMetrics()`, () => {
      describe(`before login`, () => {
        it(`posts pre-login metric`, () => {
          metrics.submitClientMetrics(eventName, mockPayload, preLoginId);
          assert.calledWith(metrics.postPreLoginMetric, preLoginProps, preLoginId);
          assert.calledOnce(spark.credentials.getClientToken);
        });
      });
      describe(`after login`, () => {
        it(`submits a metric to clientmetrics`, () => {
          return metrics.submitClientMetrics(`test`, testPayload)
            .then(() => {
              assert.calledOnce(spark.request);
              const req = spark.request.args[0][0];
              const metric = req.body.metrics[0];

              assert.property(metric, `metricName`);
              assert.property(metric, `tags`);
              assert.property(metric, `fields`);

              assert.equal(metric.metricName, `test`);
              assert.equal(metric.tags.success, true);
              assert.equal(metric.fields.perceivedDurationInMillis, testPayload.fields.perceivedDurationInMillis);
            });
        });
      });
    });

    describe(`#postPreLoginMetric()`, () => {
      it(`returns an HttpResponse object`, () => {
        return metrics.postPreLoginMetric(preLoginProps, preLoginId)
          .then(() => {
            assert.calledOnce(spark.request);
            const req = spark.request.args[0][0];
            const metric = req.body.metrics[0];
            const headers = req.headers;

            assert.property(headers, `x-prelogin-userid`);
            assert.property(metric, `metricName`);
            assert.property(metric, `tags`);
            assert.property(metric, `fields`);

            assert.equal(metric.metricName, eventName);
            assert.equal(metric.tags.testTag, `tag value`);
            assert.equal(metric.fields.testField, 123);
          });
      });
    });

    describe(`#aliasUser()`, () => {
      it(`returns an HttpResponse object`, () => {
        return metrics.aliasUser(preLoginId)
          .then(() => {
            assert.calledOnce(spark.request);
            const req = spark.request.args[0][0];
            const params = req.qs;

            sinon.match(params, {alias: true});
          });
      });
    });

    describe(`#submitCallDiagnosticEvents()`, () => {
      it(`submits a call diagnostic event`, () => {
        return metrics.submitCallDiagnosticEvents(mockCallDiagnosticEvent)
          .then(() => {
            assert.calledOnce(spark.request);
            const req = spark.request.args[0][0];
            const metric = req.body.metrics[0];

            assert.property(metric.eventPayload, `origin`);
            assert.property(metric.eventPayload, `originTime`);
            assert.property(metric.eventPayload.origin, `buildType`);
            assert.property(metric.eventPayload.origin, `networkType`);
            assert.property(metric.eventPayload.originTime, `sent`);
          });
      });
    });

    describe(`#storeMetric()`, () => {
      it(`stores a metric`, () => {
        assert.isNotNull(metrics.storeMetric(`1`, `Foo`, `clientMetric`));
        assert.equal(metrics.metricMap.size, 1);
        assert.isNotNull(metrics.storeMetric(`2`, `bar`, `clientMetric`));
        assert.equal(metrics.metricMap.size, 2);
      });
    });

    describe(`#deleteMetric`, () => {
      it(`it deletes a metric from map`, () => {
        assert.isNotNull(metrics.storeMetric(`1`, `Foo`, `clientMetric`));
        assert.equal(metrics.metricMap.size, 1);
        assert.isTrue(metrics.deleteMetric(`1`));
        assert.equal(metrics.metricMap.size, 0);
      });
    });

    describe(`#registerMetric()`, () => {
      it(`registers and stores a metric that does not exist`, () => {
        assert.isNotNull(metrics._registerMetric(`Foo`, `1`, testPayload, `clientMetric`));
        assert.equal(metrics.metricMap.size, 1);
        assert.equal(metrics.getMetric(`1`).type, `clientMetric`);
        assert.isNotNull(metrics._registerMetric(`bar`, `2`, testPayload, `clientMetric`));
        assert.equal(metrics.metricMap.size, 2);
        assert.equal(testPayload.fields, metrics.getMetric(`1`).metric.fields);
      });

      it(`does not register or store a metric that already exists`, () => {
        assert.isNotNull(metrics._registerMetric(`horse`, `1`, testPayload, `clientMetric`));
        assert.equal(metrics.metricMap.size, 1);
        assert.isFalse(metrics._registerMetric(`horse`, `1`, `BazBar`, `clientMetric`));
        assert.equal(metrics.metricMap.size, 1);
        assert.equal(testPayload.fields, metrics.getMetric(`1`).metric.fields);
      });
    });

    describe(`#registerClientMetric()`, () => {
      it(`client registers and stores a metric that does not exist`, () => {
        assert.isNotNull(metrics.registerClientMetric(`Foo`, `1`, `fooBar`));
        assert.equal(metrics.metricMap.size, 1);
        assert.isNotNull(metrics.registerClientMetric(`bar`, `2`, `barBaz`));
        assert.equal(metrics.metricMap.size, 2);
        assert.equal(metrics.getMetric(`1`).type, `clientMetric`);
        assert.equal(metrics.getMetric(`2`).type, `clientMetric`);
      });
    });

    describe(`#registerSdkMetric()`, () => {
      it(`sdk registers and stores a metric that does not exist`, () => {
        assert.isNotNull(metrics.registerMetric(`Foo`, `1`, `fooBar`));
        assert.equal(metrics.metricMap.size, 1);
        assert.isNotNull(metrics.registerMetric(`bar`, `2`, `barBaz`));
        assert.equal(metrics.metricMap.size, 2);
        assert.equal(metrics.getMetric(`1`).type, `sdkMetric`);
        assert.equal(metrics.getMetric(`2`).type, `sdkMetric`);
      });
    });

    describe(`#updateRegisteredMetric`, () => {
      it(`updates metric props`, () => {
        const updatedPayload = {
          fields: {perceivedDurationInMillis: 123, testVal2: 456}
        };
        metrics._registerMetric(`horse`, `1`, testPayload, `clientMetric`);
        assert.equal(metrics.getMetric(`1`).metric.fields.perceivedDurationInMillis, testPayload.fields.perceivedDurationInMillis);
        metrics.updateRegisteredMetric(`1`, updatedPayload);
        assert.equal(metrics.getMetric(`1`).metric.fields.perceivedDurationInMillis, 123);
        assert.equal(metrics.getMetric(`1`).metric.fields.testVal2, 456);
      });
      it(`does not update on null args`, () => {
        metrics._registerMetric(`horse`, `1`, testPayload, `clientMetric`);
        const metric = metrics.getMetric(`1`);
        assert.isFalse(metrics.updateRegisteredMetric(`1`, null));
        assert.deepEqual(metric, metrics.getMetric(`1`));
        assert.isFalse(metrics.updateRegisteredMetric(`2`, null));
        // test null type branch
        metrics._registerMetric(`testNullType`, `3`, testPayload, null);
        assert.isFalse(metrics.updateRegisteredMetric(`3`, `someValue`));
      });
    });

    describe(`#sendClientRegisteredMetric`, () => {
      it(`sends client metric`, () => {
        metrics._registerMetric(`horse`, `1`, testPayload, `clientMetric`);
        return metrics.sendClientRegisteredMetric(`1`)
          .then(() => {
            assert.calledOnce(spark.request);
            const req = spark.request.args[0][0];
            const metric = req.body.metrics[0];

            assert.property(metric, `metricName`);
            assert.property(metric, `tags`);
            assert.property(metric, `fields`);

            assert.equal(metric.metricName, `horse`);
            assert.equal(metric.tags.success, true);
            assert.equal(metric.fields.perceivedDurationInMillis, testPayload.fields.perceivedDurationInMillis);
          });
      });
      it(`does not send non-client metric`, () => {
        metrics._registerMetric(`test`, `2`, testPayload, `sdkMetric`);
        assert.isFalse(metrics.sendClientRegisteredMetric(`2`));
      });
      it(`does not send null metric`, () => {
        assert.isFalse(metrics.sendClientRegisteredMetric(`4`));
      });
    });

    describe(`#sendRegisteredMetric`, () => {
      it(`sends sdk metric`, () => {
        metrics._registerMetric(`horse`, `1`, testPayload, `sdkMetric`);
        return metrics.sendRegisteredMetric(`1`)
          .then(() => {
            assert.calledOnce(spark.request);
            const req = spark.request.args[0][0];
            const metric = req.body.metrics[0];

            assert.property(metric, `metricName`);
            assert.property(metric, `tags`);
            assert.property(metric, `fields`);

            assert.equal(metric.metricName, `horse`);
            assert.equal(metric.tags.success, true);
            assert.equal(metric.fields.perceivedDurationInMillis, testPayload.fields.perceivedDurationInMillis);
          });
      });
      it(`does not send non-sdk metric`, () => {
        metrics._registerMetric(`test`, `2`, testPayload, `clientMetric`);
        assert.isFalse(metrics.sendRegisteredMetric(`2`));
      });
      it(`does not send null metric`, () => {
        assert.isFalse(metrics.sendRegisteredMetric(`4`));
      });
    });

    describe(`#sendUnstructured`, () => {
      it(`sends an unstructured metric`, () => metrics.sendUnstructured(`foo`, `bar`)
        .then(() => {
          assert.calledOnce(spark.request);
        })
      );
    });
  });
});
