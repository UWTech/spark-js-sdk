/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {SparkPlugin} from '@ciscospark/spark-core';
import Batcher from './batcher';
import ClientMetricsBatcher from './client-metrics-batcher';
import CallDiagnosticEventsBatcher from './call-diagnostic-events-batcher';
import {deprecated} from '@ciscospark/common';

const Metrics = SparkPlugin.extend({
  children: {
    batcher: Batcher,
    clientMetricsBatcher: ClientMetricsBatcher,
    callDiagnosticEventsBatcher: CallDiagnosticEventsBatcher
  },

  props: {
    metricMap: {
      type: `object`
    }
  },

  CLIENT_METRIC: `clientMetric`,
  SDK_METRIC: `sdkMetric`,

  namespace: `Metrics`,

  @deprecated(`Metrics#sendUnstructured() is deprecated; please use Metrics#submit()`)
  sendUnstructured(key, value) {
    return this.submit(key, value);
  },

  submit(key, value) {
    return this.batcher.request(Object.assign({key}, value));
  },

  /**
   * generates a named metrics payload
   * @param {string} eventName
   * @param {Object} props
   * @returns {Object} payload
   */
  _createPayload(eventName, props) {
    const payload = {metricName: eventName};
    if (props.tags) {
      payload.tags = props.tags;
    }
    if (props.fields) {
      payload.fields = props.fields;
    }
    if (props.type) {
      payload.type = props.type;
    }
    return payload;
  },

  /**
   * This corresponds to #sendSemiStructured() in the deprecated metrics handler
   * @param {string} eventName
   * @param {Object} props
   * @param {string} preLoginId
   * @returns {Object} HttpResponse object
   */
  submitClientMetrics(eventName, props, preLoginId) {
    const payload = this._createPayload(eventName, props);

    if (preLoginId) {
      const _payload = {
        metrics: [
          payload
        ]
      };
      // Do not batch these because pre-login events occur during onboarding, so we will be partially blind
      // to users' progress through the reg flow if we wait to persist pre-login metrics for people who drop off because
      // their metrics will not post from a queue flush in time
      return this.postPreLoginMetric(_payload, preLoginId);
    }
    return this._sendBatchMetric(payload);
  },

  _sendBatchMetric(payload) {
    return this.clientMetricsBatcher.request(payload);
  },

  /**
   * Issue request to alias a user's pre-login ID with their CI UUID
   * @param {string} preLoginId
   * @returns {Object} HttpResponse object
   */
  aliasUser(preLoginId) {
    return this.request({
      method: `POST`,
      api: `metrics`,
      resource: `clientmetrics`,
      headers: {
        "x-prelogin-userid": preLoginId
      },
      body: {},
      qs: {
        alias: true
      }
    });
  },

  postPreLoginMetric(payload, preLoginId) {
    return this.spark.credentials.getClientToken()
      .then((token) => this.request({
        method: `POST`,
        api: `metrics`,
        resource: `clientmetrics-prelogin`,
        headers: {
          authorization: token.toString(),
          "x-prelogin-userid": preLoginId
        },
        body: payload
      }));
  },

  submitCallDiagnosticEvents(payload) {
    const event = {
      type: `diagnostic-event`,
      eventPayload: payload
    };
    return this.callDiagnosticEventsBatcher.request(event);
  },

  storeMetric(id, metricProps, metricType) {
    const tuple = {metric: metricProps, type: metricType};
    return this.metricMap.set(id, tuple);
  },

  getMetric(id) {
    return this.metricMap.get(id);
  },

  deleteMetric(id) {
    return this.metricMap.delete(id);
  },

  /**
   * registers (stores) a metric if it does not exist
   * returns false if the metric has been registered by another client
   * operation, or if the metric has been registered by SDK.
   * On false return, user can use secondary hashing algorithm to store under
   * different key if desired, or handle as they feel appropriate.
   * @param {string} eventName
   * @param {string} id
   * @param {Object} props
   * @param {string} type
   * @returns {bool}
   */
  _registerMetric(eventName, id, props, type) {
    if (!this.getMetric(id)) {
      // hash name and props into table/object
      const payload = this._createPayload(eventName, props);
      return this.storeMetric(id, payload, type);
    }
    return false;
  },

  /**
  * Registers a client metric to be used to later update or call finish method
  * returns false if the metric has been registered by another client
  * operation, or if the metric has been registered by SDK.
  * On false return, user can use secondary hashing algorithm to store under
  * different key if desired, or handle as they feel appropriate.
  * @param {string} eventName name of the metric
  * @param {string} id unique identifier
  * @param {Object} props to populate the metric with
  * @returns {bool} true if metric registered, false otherwise
  */
  registerClientMetric(eventName, id, props) {
    return this._registerMetric(eventName, id, props, this.CLIENT_METRIC);
  },

  /**
  * Registers a metric to be used to later update or call finish method
  * returns false if the metric has been registered by another client
  * operation, or if the metric has been registered by SDK.
  * On false return, user can use secondary hashing algorithm to store under
  * different key if desired, or handle as they feel appropriate.
  * @param {string} eventName name of the metric
  * @param {string} id unique identifier
  * @param {Object} props to populate the metric with
  * @returns {bool} true if metric registered, false otherwise
  */
  registerMetric(eventName, id, props) {
    return this._registerMetric(eventName, id, props, this.SDK_METRIC);
  },

  /**
   * Updates a registered metric, if it exists
   * returns false if the metric has been registered by another client
   * operation, or if the metric has been registered by SDK.
   * caller can process false response as appropriate
   * (e.g.: secondary hash method lookup, etc.)
   * @param {string} id lookup key for metric
   * @param {Object} metricProps to be used for updating metric
   * @returns {bool} true if the metrics exists and was updated, false otherwise
   */
  updateRegisteredMetric(id, metricProps) {
    const storedMetric = this.getMetric(id);
    const props = storedMetric ? storedMetric.metric : null;
    const type = storedMetric ? storedMetric.type : null;

    if (!props || !type || !metricProps) {
      return false;
    }

    // update metric
    Object.assign(props.fields, metricProps.fields);

    return this.storeMetric(id, props, type);
  },

  metricIsType(id, type) {
    const metric = this.getMetric(id);
    return metric && metric.type === type;
  },

  /**
   * Sends a registered metric if it exists
   * @param {string} id of the metric to be sent
   * @returns {Object} HttpResponse object
   */
  sendClientRegisteredMetric(id) {
    if (!this.metricIsType(id, this.CLIENT_METRIC)) {
      return false;
    }
    const httpResp = this._sendBatchMetric(this.getMetric(id).metric);
    this.deleteMetric(id);
    return httpResp;
  },

  /**
   * Sends a registered metric if it exists
   * @param {string} id of the metric to be sent
   * @returns {Object} HttpResponse object
   */
  sendRegisteredMetric(id) {
    if (!this.metricIsType(id, this.SDK_METRIC)) {
      return false;
    }
    const httpResp = this._sendBatchMetric(this.getMetric(id).metric);
    this.deleteMetric(id);
    return httpResp;
  }

});

export default Metrics;
