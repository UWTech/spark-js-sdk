/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {SparkPlugin} from '@ciscospark/spark-core';
import Batcher from './batcher';
import ClientMetricsBatcher from './client-metrics-batcher';
import CallDiagnosticEventsBatcher from './call-diagnostic-events-batcher';
import {deprecated} from '@ciscospark/common';
import _ from 'lodash';

const Metrics = SparkPlugin.extend({
  children: {
    batcher: Batcher,
    clientMetricsBatcher: ClientMetricsBatcher,
    callDiagnosticEventsBatcher: CallDiagnosticEventsBatcher
  },

  // design naming/lookup schema,
  // does register for already existent metric become update or is an error?

  // holds metrics which are to be updated prior to being sent
  // keyed by unique identifiers that vary depending on use.
  // const metricMap = new Map(),

  namespace: `Metrics`,

  @deprecated(`Metrics#sendUnstructured() is deprecated; please use Metrics#submit()`)
  sendUnstructured(key, value) {
    return this.submit(key, value);
  },

  submit(key, value) {
    return this.batcher.request(Object.assign({key}, value));
  },

  createPayload(eventName, props) {
    const payload = {metricName: eventName};
    if (props.tags) {
      payload.tags = props.tags;
    }
    if (props.fields) {
      payload.fields = props.fields;
    }
    if (props.type) {
      payload.type = props.type;
    }
    return payload;
  },

  /**
   * This corresponds to #sendSemiStructured() in the deprecated metrics handler
   * @param {string} eventName
   * @param {Object} props
   * @param {string} preLoginId
   * @returns {Object} HttpResponse object
   */
  submitClientMetrics(eventName, props, preLoginId) {
    const payload = this.createPayload(eventName, props);

    if (preLoginId) {
      const _payload = {
        metrics: [
          payload
        ]
      };
      // Do not batch these because pre-login events occur during onboarding, so we will be partially blind
      // to users' progress through the reg flow if we wait to persist pre-login metrics for people who drop off because
      // their metrics will not post from a queue flush in time
      return this.postPreLoginMetric(_payload, preLoginId);
    }
    return this.clientMetricsBatcher.request(payload);
  },

  /**
   * Issue request to alias a user's pre-login ID with their CI UUID
   * @param {string} preLoginId
   * @returns {Object} HttpResponse object
   */
  aliasUser(preLoginId) {
    return this.request({
      method: `POST`,
      api: `metrics`,
      resource: `clientmetrics`,
      headers: {
        "x-prelogin-userid": preLoginId
      },
      body: {},
      qs: {
        alias: true
      }
    });
  },

  postPreLoginMetric(payload, preLoginId) {
    return this.spark.credentials.getClientToken()
      .then((token) => this.request({
        method: `POST`,
        api: `metrics`,
        resource: `clientmetrics-prelogin`,
        headers: {
          authorization: token.toString(),
          "x-prelogin-userid": preLoginId
        },
        body: payload
      }));
  },

  submitCallDiagnosticEvents(payload) {
    const event = {
      type: `diagnostic-event`,
      eventPayload: payload
    };
    return this.callDiagnosticEventsBatcher.request(event);
  },

  storeMetric(id, metric) {
    // metricMap.set(id, metric);
    return id + metric;
  },

  getMetric(id) {
    // metricMap.get(id);
    return id;
  },

  registerMetric(eventName, id, props) {
    // hash name and props into table/object
    const payload = this.createPayload(eventName, props);
    return this.storeMetric(id, payload);
  },

  /**
  * Registers a metric to be used to later update or call finish method
  * @param {string} eventName name of the metric
  * @param {string} id unique identifier
  * @param {Object} props to populate the metric with
  * @returns {bool} true if metric registered, false otherwise
  */
  clientRegisterMetric(eventName, id, props) {
    return this.registerMetric(eventName, id, props);
  },

  /**
  * Registers a metric to be used to later update or call finish method
  * @param {string} eventName name of the metric
  * @param {string} id unique identifier
  * @param {Object} props to populate the metric with
  * @returns {bool} true if metric registered, false otherwise
  */
  sdkRegisterMetric(eventName, id, props) {
    return this.registerMetric(eventName, id, props);
  },

  /**
   * Updates a registered metric, if it exists
   * @param {Object} metricMap to be used for updating metric
   * @param {string} id lookup key for metric identifier for metric
   * @returns {bool} true if the metrics exists and was updated, false otherwise
   */
  clientUpdateRegisteredMetric(metricMap, id) {
    // lookup metric
    const props = this.getMetric(id);
    // update metric
    _.forOwn(metricMap, (value, key) => {
      _.assign(props, {key, value});
    });
    return this.storeMetric(id, props);
  },

  /**
   * Updates a registered metric, if it exists
   * @param {Object} props to be used of r updating metric
   * @param {string} id lookup key for metric identifier for metric
   * @returns {bool} true if the metrics exists and was updated, false otherwise
   */
  sdkUpdateRegisteredMetric(props, id) {
    // lookup metric
    // update metric
    // appropriate disposition
    return props + id;
  },

  /**
   * Sends a registered metric if it exists
   * @param {string} id of the metric to be sent
   * @returns {Object} HttpResponse object
   */
  clientSendRegisteredMetric(id) {
    // lookup metric
    // stop timer ?
    // send to batcher
    return id;
  },

  /**
   * Sends a registered metric if it exists
   * @param {string} id of the metric to be sent
   * @returns {Object} HttpResponse object
   */
  sdkSendRegisteredMetric(id) {
    // lookup metric
    // stop timer ?
    // send to batcher
    return id;
  }

});

export default Metrics;
